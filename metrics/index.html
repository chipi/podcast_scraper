<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unified Test Metrics Dashboard - Podcast Scraper</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        /* Same CSS as static dashboard */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; color: #333; line-height: 1.6; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        header { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; display: flex; flex-direction: row; gap: 40px; align-items: flex-start; }
        .header-title { flex: 1; }
        .header-alerts { flex: 1; }
        h1 { color: #2c3e50; margin-bottom: 10px; }
        .timestamp { color: #7f8c8d; font-size: 0.9em; }
        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px; }
        .metric-card { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .metric-label { color: #7f8c8d; font-size: 0.9em; margin-bottom: 8px; }
        .metric-value { font-size: 2em; font-weight: bold; color: #2c3e50; }
        .metric-trend { font-size: 0.9em; margin-top: 8px; }
        .trend-up { color: #27ae60; }
        .trend-down { color: #e74c3c; }
        .trend-neutral { color: #7f8c8d; }
        .alert { padding: 12px; border-radius: 4px; margin-bottom: 10px; border-left: 4px solid; }
        .alert-error { background: #fee; border-color: #e74c3c; color: #c0392b; }
        .alert-warning { background: #fffbf0; border-color: #f39c12; color: #d68910; }
        .alert-info { background: #ebf5fb; border-color: #3498db; color: #2874a6; }
        .chart-section { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .chart-container { position: relative; height: 300px; margin-top: 20px; }
        .slowest-tests { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { padding: 10px; text-align: left; border-bottom: 1px solid #eee; }
        th { background: #f8f9fa; font-weight: 600; color: #2c3e50; }
        .no-data { text-align: center; color: #7f8c8d; padding: 40px; }
        .source-selector { margin-bottom: 20px; background: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); display: flex; align-items: center; gap: 15px; }
        select { padding: 8px 12px; border-radius: 4px; border: 1px solid #ddd; font-size: 1em; color: #2c3e50; cursor: pointer; }
        .loader { display: none; border: 3px solid #f3f3f3; border-top: 3px solid #3498db; border-radius: 50%; width: 20px; height: 20px; animation: spin 2s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="source-selector">
            <label for="data-source"><strong>Data Source:</strong></label>
            <select id="data-source">
                <option value="ci">CI Metrics (Latest Push)</option>
                <option value="nightly">Nightly Metrics (Scheduled Runs)</option>
            </select>
            <div id="loader" class="loader"></div>
        </div>

        <header id="dashboard-header">
            <div class="header-title">
                <h1>üìä Test Metrics Dashboard</h1>
                <div class="timestamp" id="last-updated">Loading...</div>
                <div class="timestamp" id="commit-info"></div>
            </div>
            <div class="header-alerts">
                <h1>‚ö†Ô∏è Alerts</h1>
                <div id="alerts-container">Loading alerts...</div>
            </div>
        </header>

        <div class="metrics-grid" id="metrics-grid">
            <!-- Metric cards will be populated here -->
        </div>

        <div class="chart-section">
            <h2>üìà Test Metrics Trends (Last 30 Runs)</h2>
            <div class="chart-container">
                <canvas id="trendsChart"></canvas>
            </div>
        </div>

        <div class="chart-section">
            <h2>üìä Code Quality Trends (Last 30 Runs)</h2>
            <div class="chart-container">
                <canvas id="quality-chart"></canvas>
            </div>
        </div>

        <div id="pipeline-section" class="chart-section" style="display: none;">
            <h2>üöÄ Pipeline Performance Trends (Last 30 Runs)</h2>
            <div class="chart-container">
                <canvas id="pipeline-chart"></canvas>
            </div>
        </div>

        <div class="slowest-tests">
            <h2>üêå Slowest Tests (Top 10)</h2>
            <div id="slowest-tests-container"></div>
        </div>

        <div class="slowest-tests">
            <h2>‚ö†Ô∏è Flaky Tests</h2>
            <p>Tests that failed initially but passed on rerun</p>
            <div id="flaky-tests-container"></div>
        </div>
    </div>

    <script>
        let trendsChart, qualityChart, pipelineChart;

        async function loadData(source) {
            const loader = document.getElementById('loader');
            loader.style.display = 'block';

            try {
                const [latestResp, historyResp] = await Promise.all([
                    fetch(`latest-${source}.json`),
                    fetch(`history-${source}.jsonl`)
                ]);

                if (!latestResp.ok) throw new Error(`Could not load latest-${source}.json`);
                const latest = await latestResp.json();

                let history = [];
                if (historyResp.ok) {
                    const text = await historyResp.text();
                    history = text.split('\n')
                        .filter(line => line.trim())
                        .map(line => JSON.parse(line));
                }

                updateDashboard(latest, history);
            } catch (error) {
                console.error('Error loading data:', error);
                alert(`Error loading data for ${source}: ${error.message}`);
            } finally {
                loader.style.display = 'none';
            }
        }

        function formatTimestamp(ts) {
            if (!ts) return 'unknown';
            try {
                const dt = new Date(ts);
                return dt.toLocaleString();
            } catch (e) { return ts; }
        }

        function updateDashboard(latest, history) {
            const metrics = latest.metrics || {};
            const trends = latest.trends || {};
            const alerts = latest.alerts || [];

            // Update Header
            document.getElementById('last-updated').innerText = `Last updated: ${formatTimestamp(latest.timestamp)}`;
            document.getElementById('commit-info').innerHTML = `Commit: <code>${(latest.commit || 'unknown').substring(0, 8)}</code> | Branch: <code>${latest.branch || 'unknown'}</code>`;

            // Update Alerts
            const alertsContainer = document.getElementById('alerts-container');
            if (alerts.length > 0) {
                alertsContainer.innerHTML = alerts.map(a => {
                    const severity = a.severity === 'error' ? 'alert-error' : (a.severity === 'warning' ? 'alert-warning' : 'alert-info');
                    return `<div class="alert ${severity}"><strong>${(a.metric || 'unknown').toUpperCase()}</strong>: ${a.message}</div>`;
                }).join('');
            } else {
                alertsContainer.innerHTML = '<div class="no-data">‚úÖ No alerts - all metrics within normal range</div>';
            }

            // Update Metrics Grid
            const grid = document.getElementById('metrics-grid');
            const testHealth = metrics.test_health || {};
            const runtime = metrics.runtime || {};
            const coverage = metrics.coverage || {};
            const complexity = metrics.complexity || {};
            const pipeline = metrics.pipeline || {};

            let gridHtml = `
                <div class="metric-card">
                    <div class="metric-label">Total Tests</div>
                    <div class="metric-value">${testHealth.total || 0}</div>
                    ${trends.test_count_change ? `<div class="metric-trend">${trends.test_count_change}</div>` : ''}
                </div>
                <div class="metric-card">
                    <div class="metric-label">Passed</div>
                    <div class="metric-value" style="color: #27ae60;">${testHealth.passed || 0}</div>
                    <div class="metric-trend">Pass rate: ${(testHealth.pass_rate * 100 || 0).toFixed(1)}%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Failed</div>
                    <div class="metric-value" style="color: #e74c3c;">${testHealth.failed || 0}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Skipped</div>
                    <div class="metric-value" style="color: #f39c12;">${testHealth.skipped || 0}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Runtime</div>
                    <div class="metric-value">${(runtime.total || 0).toFixed(1)}s</div>
                    ${getTrendHtml(trends.runtime_change)}
                </div>
                <div class="metric-card">
                    <div class="metric-label">Coverage (threshold: ${(coverage.threshold || 80).toFixed(0)}%)</div>
                    <div class="metric-value" style="color: ${coverage.meets_threshold ? '#27ae60' : '#e74c3c'};">${(coverage.overall || 0).toFixed(1)}%</div>
                    ${getTrendHtml(trends.coverage_change)}
                </div>
                <div class="metric-card">
                    <div class="metric-label">Complexity</div>
                    <div class="metric-value">${(complexity.cyclomatic_complexity || 0).toFixed(1)}</div>
                    ${getTrendHtml(complexity.complexity_trend)}
                </div>
                <div class="metric-card">
                    <div class="metric-label">Maintainability</div>
                    <div class="metric-value">${(complexity.maintainability_index || 0).toFixed(1)}</div>
                    ${getTrendHtml(complexity.maintainability_trend)}
                </div>
                <div class="metric-card">
                    <div class="metric-label">Docstrings</div>
                    <div class="metric-value">${(complexity.docstring_coverage || 0).toFixed(1)}%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Dead Code</div>
                    <div class="metric-value" style="color: ${complexity.dead_code_count > 0 ? '#e74c3c' : '#27ae60'};">${complexity.dead_code_count || 0}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Spelling</div>
                    <div class="metric-value" style="color: ${complexity.spelling_errors_count > 0 ? '#e74c3c' : '#27ae60'};">${complexity.spelling_errors_count || 0}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Flaky Tests</div>
                    <div class="metric-value" style="color: ${testHealth.flaky > 0 ? '#e74c3c' : '#27ae60'};">${testHealth.flaky || 0}</div>
                </div>
            `;

            if (pipeline && pipeline.run_duration_seconds) {
                gridHtml += `
                    <div class="metric-card">
                        <div class="metric-label">Pipeline Duration</div>
                        <div class="metric-value">${pipeline.run_duration_seconds.toFixed(1)}s</div>
                        ${getTrendHtml(trends.pipeline_duration_change)}
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Episodes Scraped</div>
                        <div class="metric-value">${pipeline.episodes_scraped_total || 0}</div>
                        ${getTrendHtml(trends.pipeline_episodes_change)}
                    </div>
                `;
            }

            grid.innerHTML = gridHtml;

            // Update Tables
            updateTables(metrics);

            // Update Charts
            updateCharts(history);
        }

        function getTrendHtml(change) {
            if (!change) return '';
            const trendClass = change.startsWith('+') ? 'up' : (change.startsWith('-') ? 'down' : 'neutral');
            return `<div class="metric-trend trend-${trendClass}">${change}</div>`;
        }

        function updateTables(metrics) {
            const slowest = metrics.slowest_tests || [];
            const flaky = (metrics.test_health || {}).flaky_tests || [];

            const slowestContainer = document.getElementById('slowest-tests-container');
            if (slowest.length > 0) {
                slowestContainer.innerHTML = `
                    <table>
                        <thead><tr><th>Test Name</th><th>Duration</th></tr></thead>
                        <tbody>${slowest.slice(0, 10).map(t => `<tr><td><code>${t.name}</code></td><td>${t.duration.toFixed(2)}s</td></tr>`).join('')}</tbody>
                    </table>
                `;
            } else {
                slowestContainer.innerHTML = '<div class="no-data">No test duration data available</div>';
            }

            const flakyContainer = document.getElementById('flaky-tests-container');
            if (flaky.length > 0) {
                flakyContainer.innerHTML = `
                    <table>
                        <thead><tr><th>Test Name</th><th>Duration</th></tr></thead>
                        <tbody>${flaky.map(t => `<tr><td><code>${t.name}</code></td><td>${t.duration.toFixed(2)}s</td></tr>`).join('')}</tbody>
                    </table>
                `;
            } else {
                flakyContainer.innerHTML = '<div class="no-data">‚úÖ No flaky tests detected</div>';
            }
        }

        function updateCharts(history) {
            const chartHistory = history.slice(-30);
            const labels = chartHistory.map(h => (h.timestamp || '').substring(0, 10));

            // Test Metrics Trends
            const trendsData = {
                labels: labels,
                datasets: [
                    { label: 'Runtime (s)', data: chartHistory.map(h => h.metrics.runtime.total), borderColor: '#e74c3c', yAxisID: 'y', tension: 0.1 },
                    { label: 'Coverage (%)', data: chartHistory.map(h => h.metrics.coverage.overall), borderColor: '#3498db', yAxisID: 'y1', tension: 0.1 },
                    { label: 'Test Count', data: chartHistory.map(h => h.metrics.test_health.total), borderColor: '#2ecc71', yAxisID: 'y2', tension: 0.1 }
                ]
            };

            if (trendsChart) trendsChart.destroy();
            trendsChart = new Chart(document.getElementById('trendsChart'), {
                type: 'line',
                data: trendsData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        y: { type: 'linear', position: 'left', title: { display: true, text: 'Seconds' } },
                        y1: { type: 'linear', position: 'right', title: { display: true, text: '%' }, grid: { drawOnChartArea: false } },
                        y2: { display: false }
                    }
                }
            });

            // Quality Trends
            const qualityData = {
                labels: labels,
                datasets: [
                    { label: 'Complexity', data: chartHistory.map(h => h.metrics.complexity.cyclomatic_complexity), borderColor: '#e74c3c', yAxisID: 'y', tension: 0.1 },
                    { label: 'Maintainability', data: chartHistory.map(h => h.metrics.complexity.maintainability_index), borderColor: '#2ecc71', yAxisID: 'y1', tension: 0.1 },
                    { label: 'Docstrings (%)', data: chartHistory.map(h => h.metrics.complexity.docstring_coverage), borderColor: '#3498db', yAxisID: 'y2', tension: 0.1 }
                ]
            };

            if (qualityChart) qualityChart.destroy();
            qualityChart = new Chart(document.getElementById('quality-chart'), {
                type: 'line',
                data: qualityData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        y: { type: 'linear', position: 'left', title: { display: true, text: 'Index' } },
                        y1: { type: 'linear', position: 'right', title: { display: true, text: 'Index' }, grid: { drawOnChartArea: false } },
                        y2: { type: 'linear', position: 'right', title: { display: true, text: '%' }, grid: { drawOnChartArea: false } }
                    }
                }
            });

            // Pipeline Trends
            const pipelineHistory = chartHistory.filter(h => h.metrics.pipeline && h.metrics.pipeline.run_duration_seconds);
            if (pipelineHistory.length > 0) {
                document.getElementById('pipeline-section').style.display = 'block';
                const pipelineLabels = pipelineHistory.map(h => (h.timestamp || '').substring(0, 10));
                const pipelineData = {
                    labels: pipelineLabels,
                    datasets: [
                        { label: 'Duration (s)', data: pipelineHistory.map(h => h.metrics.pipeline.run_duration_seconds), borderColor: '#9b59b6', yAxisID: 'y', tension: 0.1 },
                        { label: 'Episodes', data: pipelineHistory.map(h => h.metrics.pipeline.episodes_scraped_total), borderColor: '#1abc9c', yAxisID: 'y1', tension: 0.1 }
                    ]
                };

                if (pipelineChart) pipelineChart.destroy();
                pipelineChart = new Chart(document.getElementById('pipeline-chart'), {
                    type: 'line',
                    data: pipelineData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        scales: {
                            y: { type: 'linear', position: 'left', title: { display: true, text: 'Seconds' } },
                            y1: { type: 'linear', position: 'right', title: { display: true, text: 'Count' }, grid: { drawOnChartArea: false } }
                        }
                    }
                });
            } else {
                document.getElementById('pipeline-section').style.display = 'none';
            }
        }

        document.getElementById('data-source').addEventListener('change', (e) => {
            loadData(e.target.value);
        });

        // Initial load
        loadData('ci');
    </script>
</body>
</html>
