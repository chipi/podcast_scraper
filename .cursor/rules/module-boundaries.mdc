# Module Boundaries - Architecture Constraints

**For complete architecture:** `docs/ARCHITECTURE.md`

## üö® CRITICAL: Respect Module Boundaries

**NEVER mix concerns across module boundaries.**

## Module Responsibility Matrix

| Module | Responsibility | ‚úÖ CAN Do | ‚ùå CANNOT Do |
|--------|----------------|----------|--------------|
| `cli.py` | CLI interface | Parse args, display output | Business logic, HTTP, file I/O |
| `service.py` | Service API | Return structured results | CLI interaction, user prompts |
| `workflow.py` | Orchestration | Call modules, coordinate flow | HTTP details, parsing, direct I/O |
| `config.py` | Configuration | Model validation | Business logic, side effects |
| `downloader.py` | HTTP operations | Retry logic, requests | Parsing, business logic |
| `rss_parser.py` | RSS parsing | Parse XML, create Episodes | HTTP calls, file I/O |
| `episode_processor.py` | Episode processing | Process single episode | CLI interaction, orchestration |
| `filesystem.py` | File utilities | Read/write files, paths | HTTP, parsing, business logic |
| `whisper_integration.py` | Whisper interface | Transcription | HTTP, RSS parsing |
| `speaker_detection.py` | NER extraction | Detect speakers | HTTP, file I/O |
| `summarizer.py` | Summarization | Generate summaries | Episode processing, HTTP |
| `metadata.py` | Metadata generation | Create JSON/YAML | HTTP, RSS parsing |
| `progress.py` | Progress reporting | Abstract progress bar | Business logic |

## Common Violations to Avoid

### ‚ùå BAD: Adding HTTP to cli.py

```python
# cli.py - WRONG!
import requests

def main():
    response = requests.get(url)  # ‚ùå NO! Use downloader.py
```

### ‚úÖ GOOD: CLI calls downloader

```python
# cli.py - CORRECT
from podcast_scraper import downloader

def main():
    content = downloader.fetch_url(url)  # ‚úÖ Use proper module
```

### ‚ùå BAD: Business logic in config.py

```python
# config.py - WRONG!
class Config(BaseModel):
    def process_episodes(self):  # ‚ùå NO! This is business logic
        pass
```

### ‚úÖ GOOD: Config only validates

```python
# config.py - CORRECT
class Config(BaseModel):
    rss_url: str
    max_episodes: Optional[int]

    @validator("max_episodes")
    def validate_positive(cls, v):  # ‚úÖ Validation only
        if v is not None and v < 1:
            raise ValueError("Must be positive")
        return v
```

### ‚ùå BAD: CLI interaction in service.py

```python
# service.py - WRONG!
def run(cfg):
    print("Processing...")  # ‚ùå NO! Service is non-interactive
    answer = input("Continue? ")  # ‚ùå NO! No user prompts
```

### ‚úÖ GOOD: Service returns structured results

```python
# service.py - CORRECT
def run(cfg: Config) -> ServiceResult:
    # Process silently
    return ServiceResult(  # ‚úÖ Structured result
        episodes_processed=5,
        summary="Processed 5 episodes",
        success=True
    )
```

## Import Organization (isort-compatible)

```python
# Group 1: stdlib (alphabetical)
import os
from pathlib import Path
from typing import Optional, List, Dict

# Group 2: third-party (alphabetical)
import requests
from pydantic import BaseModel

# Group 3: local (alphabetical)
from podcast_scraper import config
from podcast_scraper.models import Episode
```

## Lazy Loading Pattern

### __init__.py Uses Lazy Loading

**Why:** Prevents circular imports

```python
# __init__.py uses __getattr__ for lazy loading
from podcast_scraper import cli, service  # ‚úÖ Works (lazy loaded)
import podcast_scraper.cli as cli         # ‚úÖ Also works
```

**When adding new lazy-loaded modules:**

1. Add to `__getattr__` in `__init__.py`
2. Add to `_import_cache` for caching
3. Update `__all__` if needed

## Configuration Pattern

### All Runtime Options in Config

```python
# ‚úÖ GOOD - Centralized configuration
cfg = Config(
    rss_url="https://example.com/feed.xml",
    transcribe_missing=True,
    workers=8
)
run_pipeline(cfg)

# ‚ùå BAD - Scattered parameters
fetch_rss(url, timeout=30)
download(episodes, workers=8)
transcribe(jobs, model="base")
```

### Benefits

- Single source of truth
- Validation in one place (Pydantic)
- Easy to pass through call chain
- Testable (mock Config object)

## Data Flow

```text
RSS Feed ‚Üí rss_parser.py (parse)
         ‚Üí episode_processor.py (process each episode)
         ‚Üí downloader.py (HTTP operations)
         ‚Üí whisper_integration.py (transcription)
         ‚Üí speaker_detection.py (NER)
         ‚Üí summarizer.py (summarization)
         ‚Üí metadata.py (generate metadata)
         ‚Üí filesystem.py (write files)
```

**Key principle:** Each module does ONE thing and does it well.

## When Refactoring

### Ask These Questions

1. **Does this module already exist?** ‚Üí Use it, don't duplicate
2. **Am I mixing concerns?** ‚Üí Split into appropriate modules
3. **Is this business logic in CLI?** ‚Üí Move to service/workflow
4. **Am I doing HTTP in config?** ‚Üí Move to downloader
5. **Am I parsing in downloader?** ‚Üí Move to appropriate parser

### Creating New Modules

**Create new module when:**
- Implementing new major feature (>500 lines)
- Feature has distinct responsibility (SRP)
- Feature can be tested independently

**Modify existing when:**
- Fixing bugs in existing functionality
- Enhancing existing features (<200 lines added)
- Refactoring within same module

**Don't create:**
- Helper modules with only 1-2 functions (add to appropriate existing module)
- Duplicate functionality (search codebase first)
- Temporary files (use proper temporary directories)

## Testing Boundaries

### Each Module Tested Independently

```python
# test_downloader.py - Tests ONLY downloader
@patch("podcast_scraper.downloader.requests.Session")
def test_fetch_url(mock_session):
    # No imports from rss_parser, workflow, etc.
    pass

# test_rss_parser.py - Tests ONLY parser
def test_parse_feed():
    # No HTTP calls, no file I/O
    pass
```

## Provider-Specific Code (CRITICAL)

**üö® Provider-specific code MUST stay in the provider module - NEVER in central config/workflow**

**Rule:** All provider-specific concerns (logging, SDK configuration, error handling, etc.) must be encapsulated within the provider module itself. Central configuration (`workflow.py`, `config.py`) must NOT contain provider-specific logic.

### ‚ùå BAD: Provider-specific code in central config

```python
# workflow.py - WRONG!
def apply_log_level(level: str):
    # ... setup logging ...
    # ‚ùå NO! OpenAI-specific logging config doesn't belong here
    openai_logger = logging.getLogger("openai._base_client")
    openai_logger.setLevel(logging.WARNING)
```

### ‚úÖ GOOD: Provider manages its own concerns

```python
# openai/openai_provider.py - CORRECT
class OpenAIProvider:
    def __init__(self, cfg: Config):
        # ‚úÖ Provider-specific logging config belongs here
        root_logger = logging.getLogger()
        if root_logger.level <= logging.DEBUG:
            openai_logger = logging.getLogger("openai._base_client")
            openai_logger.setLevel(logging.WARNING)
        # ... rest of provider initialization ...
```

**Examples of provider-specific concerns:**
- SDK logging configuration
- SDK initialization parameters
- Provider-specific error handling
- Provider-specific retry logic
- Provider-specific rate limiting
- Provider-specific authentication setup

**Why this matters:**
- **Encapsulation**: Each provider is self-contained
- **Separation of concerns**: Central code doesn't need to know provider internals
- **Maintainability**: Provider changes don't affect central code
- **Testability**: Providers can be tested in isolation

## Quick Checklist Before Commit

- [ ] Did I add HTTP calls to non-downloader modules? ‚Üí ‚ùå Move to downloader
- [ ] Did I add business logic to config.py? ‚Üí ‚ùå Move to workflow/service
- [ ] Did I add CLI prompts to service.py? ‚Üí ‚ùå Service is non-interactive
- [ ] Did I add parsing to downloader.py? ‚Üí ‚ùå Move to appropriate parser
- [ ] Did I add provider-specific code to workflow.py or config.py? ‚Üí ‚ùå Move to provider module
- [ ] Are imports organized (stdlib ‚Üí third-party ‚Üí local)? ‚Üí ‚úÖ Use isort
- [ ] Am I using lazy loading correctly? ‚Üí ‚úÖ Check __init__.py pattern

## Remember

1. **One module, one responsibility** - SRP (Single Responsibility Principle)
2. **CLI is interface only** - No business logic
3. **Service is non-interactive** - No user prompts
4. **Workflow orchestrates** - Doesn't do the work itself
5. **Config validates** - No side effects
6. **Use existing modules** - Don't duplicate functionality

---

**Version:** 1.0
**Created:** 2026-01-07
**Source:** Distilled from `docs/ARCHITECTURE.md` and `.ai-coding-guidelines.md`
