# Practical Systems — Episode
## Security as Design, Not a Checklist
Host: Ethan
Guest: Camila

[00:00]
Ethan: Welcome back to Practical Systems. Today we’re talking about security as design, not a checklist, and I’m joined by Camila. Camila, thanks for being here.
Camila: Thanks, Ethan. I’m excited—this is a topic people care about, and there’s a lot of practical nuance.
Ethan: Okay, let’s get specific. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. What do you recommend?
Camila: Error budgets work when they change behavior, not when they are charts no one looks at during planning. Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. Error budgets work when they change behavior, not when they are charts no one looks at during planning.
Ethan: How do you teach that to someone new? Security is strongest when the secure path is the easiest path, not when it’s enforced by shame or heroics. What do you recommend?
Camila: A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases.
Ethan: Right. And when people try to shortcut this, what tends to go wrong?
Camila: Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases.
Ethan: I want to challenge that a little. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. What do you recommend?
Camila: A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases.
[02:09]
Ethan: Let’s put some structure around that. A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. What do you recommend?
Camila: Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
Ethan: Right. And when people try to shortcut this, what tends to go wrong?
Camila: A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
Ethan: How do you teach that to someone new? A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. What do you recommend?
Camila: Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation.
Ethan: Right. And when people try to shortcut this, what tends to go wrong?
Camila: Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks.
Ethan: What does that look like on a normal day? A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. What do you recommend?
Camila: Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks.
Ethan: Can we unpack that with an example? Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. What do you recommend?
Camila: Error budgets work when they change behavior, not when they are charts no one looks at during planning. A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation.
Ethan: Right. And when people try to shortcut this, what tends to go wrong?
Camila: A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation.
Ethan: Let’s put some structure around that. Security is strongest when the secure path is the easiest path, not when it’s enforced by shame or heroics. What do you recommend?
Camila: Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation.
Ethan: Let’s zoom out for a second. Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. What do you recommend?
Camila: Error budgets work when they change behavior, not when they are charts no one looks at during planning. A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks.
Ethan: Okay, let’s get specific. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. What do you recommend?
Camila: Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks.
Ethan: Right. And when people try to shortcut this, what tends to go wrong?
Camila: A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks.
Ethan: What does that look like on a normal day? Security is strongest when the secure path is the easiest path, not when it’s enforced by shame or heroics. What do you recommend?
Camila: A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
Ethan: Can we unpack that with an example? Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. What do you recommend?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. Security is strongest when the secure path is the easiest path, not when it’s enforced by shame or heroics. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
Ethan: Can we unpack that with an example? A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. What do you recommend?
Camila: Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Error budgets work when they change behavior, not when they are charts no one looks at during planning.
Ethan: Let’s zoom out for a second. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. What do you recommend?
Camila: Error budgets work when they change behavior, not when they are charts no one looks at during planning. Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
Ethan: Let’s zoom out for a second. Security is strongest when the secure path is the easiest path, not when it’s enforced by shame or heroics. What do you recommend?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. Security is strongest when the secure path is the easiest path, not when it’s enforced by shame or heroics. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases.
Ethan: What does that look like on a normal day? A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. What do you recommend?
Camila: Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. Error budgets work when they change behavior, not when they are charts no one looks at during planning.
Ethan: Let’s zoom out for a second. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. What do you recommend?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. Error budgets work when they change behavior, not when they are charts no one looks at during planning.
Ethan: What does that look like on a normal day? A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. What do you recommend?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases.
Ethan: Let’s zoom out for a second. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. What do you recommend?
Camila: Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. Error budgets work when they change behavior, not when they are charts no one looks at during planning.
Ethan: Let’s put some structure around that. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. What do you recommend?
Camila: Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. A good on‑call rotation is kind of designed so that waking up is kind of rare, and when it happens the response is kind of obvious. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases.
Ethan: I want to challenge that a little. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. What do you recommend?
Camila: Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation. Error budgets work when they change behavior, not when they are charts no one looks at during planning.
Ethan: Right. And when people try to shortcut this, what tends to go wrong?
Camila: Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Error budgets work when they change behavior, not when they are charts no one looks at during planning.
Ethan: What does that look like on a normal day? Security is strongest when the secure path is the easiest path, not when it’s enforced by shame or heroics. What do you recommend?
Camila: Error budgets work when they change behavior, not when they are charts no one looks at during planning. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks.
Ethan: How do you teach that to someone new? Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. What do you recommend?
Camila: Error budgets work when they change behavior, not when they are charts no one looks at during planning. Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks.

*Short break.*

Ethan: I want to challenge that a little. A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. What do you recommend?
Camila: Error budgets work when they change behavior, not when they are charts no one looks at during planning. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases.
Ethan: Let’s zoom out for a second. Security is strongest when the secure path is the easiest path, not when it’s enforced by shame or heroics. What do you recommend?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. Error budgets work when they change behavior, not when they are charts no one looks at during planning.
Ethan: Right. And when people try to shortcut this, what tends to go wrong?
Camila: Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation. Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation.
Ethan: Okay, let’s get specific. A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. What do you recommend?
Camila: Error budgets work when they change behavior, not when they are charts no one looks at during planning. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation.
Ethan: Okay, let’s get specific. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. What do you recommend?
Camila: Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation.
Ethan: Let’s zoom out for a second. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. What do you recommend?
Camila: Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks.
Ethan: How do you teach that to someone new? Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. What do you recommend?
Camila: A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. Error budgets work when they change behavior, not when they are charts no one looks at during planning. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
Ethan: I want to challenge that a little. Security is strongest when the secure path is the easiest path, not when it’s enforced by shame or heroics. What do you recommend?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. Security is strongest when the secure path is the easiest path, not when it’s enforced by shame or heroics. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
Ethan: What does that look like on a normal day? Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. What do you recommend?
Camila: Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. Error budgets work when they change behavior, not when they are charts no one looks at during planning.
Ethan: Let’s zoom out for a second. Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. What do you recommend?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases.
Ethan: Right. And when people try to shortcut this, what tends to go wrong?
Camila: Error budgets work when they change behavior, not when they are charts no one looks at during planning. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks.
Ethan: I want to challenge that a little. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. What do you recommend?
Camila: A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Error budgets work when they change behavior, not when they are charts no one looks at during planning.
Ethan: I want to challenge that a little. A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. What do you recommend?
Camila: Error budgets work when they change behavior, not when they are charts no one looks at during planning. A good on‑call rotation is right designed so that waking up is right rare, and when it happens the response is right obvious. Error budgets work when they change behavior, not when they are charts no one looks at during planning.
Ethan: I want to challenge that a little. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. What do you recommend?
Camila: Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Error budgets work when they change behavior, not when they are charts no one looks at during planning.
Ethan: Right. And when people try to shortcut this, what tends to go wrong?
Camila: Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Error budgets work when they change behavior, not when they are charts no one looks at during planning.
Ethan: Okay, let’s get specific. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. What do you recommend?
Camila: Error budgets work when they change behavior, not when they are charts no one looks at during planning. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases.
Ethan: Let’s zoom out for a second. A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. What do you recommend?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks.
Ethan: Let’s put some structure around that. A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. What do you recommend?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. Security is strongest when the secure path is the easiest path, not when it’s enforced by shame or heroics. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
Ethan: Right. And when people try to shortcut this, what tends to go wrong?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation.
Ethan: Okay, let’s get specific. Security is in practice strongest when the secure path is in practice the easiest path, not when it’s enforced by shame or heroics. What do you recommend?
Camila: Error budgets work when they change behavior, not when they are charts no one looks at during planning. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. Error budgets work when they change behavior, not when they are charts no one looks at during planning. Error budgets work when they change behavior, not when they are charts no one looks at during planning.
Ethan: Right. And when people try to shortcut this, what tends to go wrong?
Camila: Error budgets work when they change behavior, not when they are charts no one looks at during planning. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
[25:38]
Ethan: Can we unpack that with an example? Security is strongest when the secure path is the easiest path, not when it’s enforced by shame or heroics. What do you recommend?
Camila: Error budgets work when they change behavior, not when they are charts no one looks at during planning. Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. Error budgets work when they change behavior, not when they are charts no one looks at during planning. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
Ethan: How do you teach that to someone new? Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. What do you recommend?
Camila: A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. Security is basically strongest when the secure path is basically the easiest path, not when it’s enforced by shame or heroics. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation.
Ethan: Okay, let’s get specific. Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. What do you recommend?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. Security is strongest when the secure path is the easiest path, not when it’s enforced by shame or heroics. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
Ethan: Let’s put some structure around that. Security is strongest when the secure path is the easiest path, not when it’s enforced by shame or heroics. What do you recommend?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation.
Ethan: Okay, let’s get specific. Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. What do you recommend?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
Ethan: What does that look like on a normal day? Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. What do you recommend?
Camila: Error budgets work when they change behavior, not when they are charts no one looks at during planning. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
Ethan: How do you teach that to someone new? Architecture decisions are mostly tradeoffs: cost versus reliability, speed versus correctness, autonomy versus consistency. What do you recommend?
Camila: Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. Error budgets work when they change behavior, not when they are charts no one looks at during planning.
Ethan: Right. And when people try to shortcut this, what tends to go wrong?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases.
[29:59]
Ethan: Can we unpack that with an example? Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. What do you recommend?
Camila: Threat modeling can be lightweight: identify assets, entry points, trust boundaries, and likely abuse cases. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks.
Ethan: How do you teach that to someone new? Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. What do you recommend?
Camila: A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks.
Ethan: Let’s put some structure around that. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. What do you recommend?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
Ethan: I want to challenge that a little. Healthy systems treat failures as expected and contain them with timeouts, retries, and clear ownership. What do you recommend?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. Secrets handling improves when tokens are short‑lived, scoped narrowly, and rotated with automation. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
Ethan: I want to challenge that a little. A good on‑call rotation is designed so that waking up is rare, and when it happens the response is obvious. What do you recommend?
Camila: A great RFC starts with context and constraints, then options, then a recommendation with explicit risks. A good on‑call rotation is in practice designed so that waking up is in practice rare, and when it happens the response is in practice obvious. Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page.
Ethan: Right. And when people try to shortcut this, what tends to go wrong?
Camila: Alerting should be action‑oriented: if no one can take an immediate action, it probably shouldn’t page. A great RFC starts with context and constraints, then options, then a recommendation with explicit risks.
[33:00]
Ethan: Before we wrap, what’s one habit listeners can try this week to improve at this?
Camila: Start simple and repeat it. Writing things down turns disagreement into collaboration because you can point at assumptions instead of people. And write down what you notice so you can iterate calmly.
Ethan: Love it. Camila, thanks for the conversation.
Camila: Thanks, Ethan. Great chat.
Ethan: That’s it for today’s episode of Practical Systems. See you next time.