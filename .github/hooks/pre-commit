#!/bin/bash
#
# Git pre-commit hook template
# 
# This hook runs checks ONLY on staged files:
# - Black & isort formatting checks (Python files)
# - flake8 linting (Python files)
# - markdownlint on markdown files
# - JSON syntax validation (JSON files)
# - YAML syntax validation (YAML/YML files)
# - mypy type checking (Python files)
#
# To customize this template:
# 1. Copy this file to .github/hooks/pre-commit
# 2. Replace the placeholders below with your project-specific values:
#    - podcast_scraper - Your project name
#    - tests/integration - Path to integration tests (e.g., tests/integration)
#    - tests/workflow_e2e - Path to E2E tests (e.g., tests/workflow_e2e)
#    - integration - pytest marker for integration tests (e.g., integration)
#    - workflow_e2e - pytest marker for E2E tests (e.g., workflow_e2e)
#    - .flake8 - Path to flake8 config (e.g., .flake8)
#    - pyproject.toml - Path to mypy config (e.g., pyproject.toml)
#    - .markdownlint.json - Path to markdownlint config (e.g., .markdownlint.json)
#
# To install: run `make install-hooks` or manually:
#   cp .github/hooks/pre-commit .git/hooks/pre-commit
#   chmod +x .git/hooks/pre-commit
#
# To skip the hook for a specific commit:
#   git commit --no-verify

set -e

echo "ğŸ” Running pre-commit checks on staged files..."
echo ""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

ERRORS=0

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$STAGED_FILES" ]; then
    echo -e "${YELLOW}âš ${NC} No staged files to check"
    exit 0
fi

# Filter staged files by type
STAGED_PYTHON=$(echo "$STAGED_FILES" | grep -E '\.(py)$' || true)
STAGED_MARKDOWN=$(echo "$STAGED_FILES" | grep -E '\.(md)$' || true)
STAGED_JSON=$(echo "$STAGED_FILES" | grep -E '\.(json)$' || true)
STAGED_YAML=$(echo "$STAGED_FILES" | grep -E '\.(yaml|yml)$' || true)

# Function to run a check and track errors
run_check() {
    local name="$1"
    local command="$2"
    
    echo "â†’ Running $name..."
    if eval "$command" > /tmp/precommit_$$.log 2>&1; then
        echo -e "${GREEN}âœ“${NC} $name passed"
    else
        echo -e "${RED}âœ—${NC} $name failed"
        cat /tmp/precommit_$$.log
        ERRORS=$((ERRORS + 1))
    fi
    rm -f /tmp/precommit_$$.log
    echo ""
}

# Check if there are any Python files to check
if [ -n "$STAGED_PYTHON" ]; then
    # Convert newline-separated list to space-separated for commands
    PYTHON_FILES=$(echo "$STAGED_PYTHON" | tr '\n' ' ')
    
    # Check formatting on staged Python files
    run_check "Black formatting" "black --check $PYTHON_FILES"
    run_check "isort import sorting" "isort --check-only $PYTHON_FILES"
    
    # Check linting on staged Python files
    # Run flake8 with full config (checks all errors, respects .flake8 config)
    # This matches CI behavior: CI runs flake8 twice (critical + all), but pre-commit checks all at once
    run_check "flake8 linting" "flake8 --config .flake8 $PYTHON_FILES --count --show-source --statistics"
    
    # Check types on staged Python files
    # Note: mypy works better when checking the whole project, but we can check specific files
    # For better accuracy, we'll check the whole project but only report errors in staged files
    echo "â†’ Running mypy type checking..."
    if mypy --config-file pyproject.toml . > /tmp/precommit_mypy_$$.log 2>&1; then
        echo -e "${GREEN}âœ“${NC} mypy type checking passed"
    else
        # Filter mypy output to only show errors for staged files
        FILTERED_ERRORS=$(grep -f <(echo "$STAGED_PYTHON" | sed 's|^|^|' | sed 's|$|:|') /tmp/precommit_mypy_$$.log || true)
        if [ -n "$FILTERED_ERRORS" ]; then
            echo -e "${RED}âœ—${NC} mypy type checking failed (errors in staged files)"
            echo "$FILTERED_ERRORS"
            ERRORS=$((ERRORS + 1))
        else
            echo -e "${GREEN}âœ“${NC} mypy type checking passed (no errors in staged files)"
        fi
    fi
    rm -f /tmp/precommit_mypy_$$.log
    echo ""
else
    echo -e "${YELLOW}âš ${NC} No Python files staged, skipping Python checks"
    echo ""
fi

# Check markdown linting (required when markdown files are staged)
if [ -n "$STAGED_MARKDOWN" ]; then
    if command -v markdownlint >/dev/null 2>&1; then
        MARKDOWN_FILES=$(echo "$STAGED_MARKDOWN" | tr '\n' ' ')
        # Use same ignore patterns as make lint-markdown
        # Check if auto-fix is requested via environment variable
        if [ "$MARKDOWNLINT_FIX" = "1" ]; then
            echo "â†’ Auto-fixing markdown linting issues..."
            if markdownlint --fix $MARKDOWN_FILES --ignore node_modules --ignore .venv --ignore .build/site --config .markdownlint.json > /tmp/precommit_md_$$.log 2>&1; then
                echo -e "${GREEN}âœ“${NC} Markdown auto-fix completed"
                # Re-stage fixed files
                echo "$MARKDOWN_FILES" | xargs git add 2>/dev/null || true
            else
                echo -e "${YELLOW}âš ${NC} Some markdown issues could not be auto-fixed"
                cat /tmp/precommit_md_$$.log
            fi
            rm -f /tmp/precommit_md_$$.log
            echo ""
        fi
        # Run linting check (after auto-fix if enabled)
        # Use same config as CI (make lint-markdown) to ensure consistency
        run_check "Markdown linting" "markdownlint $MARKDOWN_FILES --ignore node_modules --ignore .venv --ignore .build/site --config .markdownlint.json"
    else
        echo -e "${RED}âœ—${NC} markdownlint not found but markdown files are staged"
        echo ""
        echo "Markdown linting is required when committing markdown files."
        echo "Install markdownlint with:"
        echo "  npm install -g markdownlint-cli"
        echo ""
        echo "Or skip this check with: git commit --no-verify"
        echo ""
        echo "Tip: Enable auto-fix by setting MARKDOWNLINT_FIX=1 before committing"
        echo ""
        ERRORS=$((ERRORS + 1))
    fi
else
    echo -e "${YELLOW}âš ${NC} No markdown files staged, skipping markdown checks"
    echo ""
fi

# Check JSON syntax validation (required when JSON files are staged)
if [ -n "$STAGED_JSON" ]; then
    echo "â†’ Running JSON syntax validation..."
    JSON_ERRORS=0
    for json_file in $STAGED_JSON; do
        if python3 -m json.tool "$json_file" > /dev/null 2>&1; then
            echo -e "  ${GREEN}âœ“${NC} $json_file"
        else
            echo -e "  ${RED}âœ—${NC} $json_file"
            python3 -m json.tool "$json_file" 2>&1 | head -5
            JSON_ERRORS=$((JSON_ERRORS + 1))
        fi
    done
    if [ $JSON_ERRORS -eq 0 ]; then
        echo -e "${GREEN}âœ“${NC} JSON syntax validation passed"
    else
        echo -e "${RED}âœ—${NC} JSON syntax validation failed ($JSON_ERRORS file(s) with errors)"
        ERRORS=$((ERRORS + 1))
    fi
    echo ""
else
    echo -e "${YELLOW}âš ${NC} No JSON files staged, skipping JSON checks"
    echo ""
fi

# Validate test infrastructure (when pytest config or test files change)
# Customize these patterns based on your project structure
STAGED_PYPROJECT=$(echo "$STAGED_FILES" | grep -E '(pyproject\.toml|Makefile|\.github/workflows/.*\.yml)$' || true)
STAGED_TEST_FILES=$(echo "$STAGED_FILES" | grep -E 'tests/.*\.py$' || true)

if [ -n "$STAGED_PYPROJECT" ] || [ -n "$STAGED_TEST_FILES" ]; then
    echo "â†’ Validating test infrastructure..."
    # Check that integration marker works
    # Note: grep -c outputs "0" on no matches but returns exit code 1, so we use || true to suppress the exit code
    INTEGRATION_COUNT=$(python3 -m pytest tests/integration/ -m integration --collect-only -q 2>&1 | grep -c "^tests/" || true)
    # Strip any newlines and ensure we have a valid number (default to 0 if empty)
    INTEGRATION_COUNT=${INTEGRATION_COUNT//$'\n'/}
    INTEGRATION_COUNT=${INTEGRATION_COUNT:-0}
    if [ "$INTEGRATION_COUNT" -eq 0 ]; then
        echo -e "${RED}âœ—${NC} Integration marker not working! No tests collected with -m integration"
        echo "  Check pyproject.toml addopts for marker conflicts"
        ERRORS=$((ERRORS + 1))
    else
        echo -e "  ${GREEN}âœ“${NC} Integration marker: $INTEGRATION_COUNT tests"
    fi
    
    # Check that E2E marker works
    # Note: grep -c outputs "0" on no matches but returns exit code 1, so we use || true to suppress the exit code
    E2E_COUNT=$(python3 -m pytest tests/e2e/ -m e2e --collect-only -q 2>&1 | grep -c "^tests/" || true)
    # Strip any newlines and ensure we have a valid number (default to 0 if empty)
    E2E_COUNT=${E2E_COUNT//$'\n'/}
    E2E_COUNT=${E2E_COUNT:-0}
    if [ "$E2E_COUNT" -eq 0 ]; then
        echo -e "${RED}âœ—${NC} E2E marker not working! No tests collected with -m e2e"
        echo "  Check pyproject.toml addopts for marker conflicts"
        ERRORS=$((ERRORS + 1))
    else
        echo -e "  ${GREEN}âœ“${NC} E2E marker: $E2E_COUNT tests"
    fi
    
    if [ $ERRORS -eq 0 ]; then
        echo -e "${GREEN}âœ“${NC} Test infrastructure validation passed"
    fi
    echo ""
fi

# Check YAML syntax validation (required when YAML files are staged)
if [ -n "$STAGED_YAML" ]; then
    echo "â†’ Running YAML syntax validation..."
    YAML_ERRORS=0
    for yaml_file in $STAGED_YAML; do
        # Try yamllint first if available (better error messages and handles custom tags)
        if command -v yamllint >/dev/null 2>&1; then
            if yamllint "$yaml_file" > /tmp/precommit_yaml_$$.log 2>&1; then
                echo -e "  ${GREEN}âœ“${NC} $yaml_file"
            else
                echo -e "  ${RED}âœ—${NC} $yaml_file"
                cat /tmp/precommit_yaml_$$.log | head -5
                YAML_ERRORS=$((YAML_ERRORS + 1))
            fi
            rm -f /tmp/precommit_yaml_$$.log
        else
            # Fallback to Python yaml module - check basic syntax (ignore custom tags)
            # Use a custom loader that ignores unknown tags for basic syntax validation
            if python3 -c "
import yaml
import sys
try:
    with open('$yaml_file', 'r') as f:
        # Try to parse YAML - if it fails, it's a syntax error
        list(yaml.safe_load_all(f))
    sys.exit(0)
except yaml.YAMLError as e:
    # Only fail on actual YAML syntax errors, not unknown tags
    if 'could not determine a constructor' in str(e) or 'tag:' in str(e):
        # Unknown tag - this is OK for syntax validation
        sys.exit(0)
    else:
        # Real syntax error
        print(e, file=sys.stderr)
        sys.exit(1)
except Exception as e:
    print(e, file=sys.stderr)
    sys.exit(1)
" > /tmp/precommit_yaml_$$.log 2>&1; then
                echo -e "  ${GREEN}âœ“${NC} $yaml_file"
            else
                echo -e "  ${RED}âœ—${NC} $yaml_file"
                cat /tmp/precommit_yaml_$$.log | head -5
                YAML_ERRORS=$((YAML_ERRORS + 1))
            fi
            rm -f /tmp/precommit_yaml_$$.log
        fi
    done
    if [ $YAML_ERRORS -eq 0 ]; then
        echo -e "${GREEN}âœ“${NC} YAML syntax validation passed"
    else
        echo -e "${RED}âœ—${NC} YAML syntax validation failed ($YAML_ERRORS file(s) with errors)"
        ERRORS=$((ERRORS + 1))
    fi
    echo ""
else
    echo -e "${YELLOW}âš ${NC} No YAML files staged, skipping YAML checks"
    echo ""
fi

# Summary
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
if [ $ERRORS -eq 0 ]; then
    echo -e "${GREEN}âœ“ All pre-commit checks passed!${NC}"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    exit 0
else
    echo -e "${RED}âœ— $ERRORS check(s) failed!${NC}"
    echo ""
    echo "Fix the issues above or use:"
    echo "  â€¢ make format       - Auto-fix formatting"
    echo "  â€¢ git commit --no-verify - Skip checks (not recommended)"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    exit 1
fi

