#!/bin/bash
#
# Git pre-commit hook template
#
# This hook runs checks ONLY on staged files:
# - Black & isort formatting checks (Python files)
# - flake8 linting (Python files)
# - markdownlint on markdown files
# - JSON syntax validation (JSON files)
# - YAML syntax validation (YAML/YML files)
# - mypy type checking (Python files)
#
# To customize this template:
# 1. Copy this file to .github/hooks/pre-commit
# 2. Replace the placeholders below with your project-specific values:
#    - podcast_scraper - Your project name
#    - tests/integration - Path to integration tests (e.g., tests/integration)
#    - tests/workflow_e2e - Path to E2E tests (e.g., tests/workflow_e2e)
#    - integration - pytest marker for integration tests (e.g., integration)
#    - workflow_e2e - pytest marker for E2E tests (e.g., workflow_e2e)
#    - .flake8 - Path to flake8 config (e.g., .flake8)
#    - pyproject.toml - Path to mypy config (e.g., pyproject.toml)
#    - .markdownlint.json - Path to markdownlint config (e.g., .markdownlint.json)
#
# To install: run `make install-hooks` or manually:
#   cp .github/hooks/pre-commit .git/hooks/pre-commit
#   chmod +x .git/hooks/pre-commit
#
# To skip the hook for a specific commit (not recommended):
#   git commit --no-verify

# Don't use set -e - we want to collect all errors, not exit on first failure
set +e

# Colors for output (define early so they can be used anywhere)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Create a temporary directory for log files (more reliable than /tmp)
TMPDIR="${TMPDIR:-/tmp}"
HOOK_TMPDIR="${HOOK_TMPDIR:-$TMPDIR}"
LOG_DIR=$(mktemp -d "${HOOK_TMPDIR}/precommit_XXXXXX" 2>/dev/null || echo "$TMPDIR")
HOOK_PID=$$
LOG_PREFIX="${LOG_DIR}/precommit_${HOOK_PID}"

# Cleanup function
cleanup() {
    rm -rf "${LOG_DIR}/precommit_${HOOK_PID}"* 2>/dev/null || true
}
trap cleanup EXIT

# Function to safely check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to check if a file exists and is readable
file_exists() {
    [ -f "$1" ] && [ -r "$1" ]
}

# Detect Python and tool paths (prefer venv, fallback to system)
# This matches the Makefile behavior: use .venv/bin/python if available
if [ -f ".venv/bin/python3" ]; then
    PYTHON_CMD=".venv/bin/python3"
    BLACK_CMD=".venv/bin/black"
    ISORT_CMD=".venv/bin/isort"
    FLAKE8_CMD=".venv/bin/flake8"
    MYPY_CMD=".venv/bin/mypy"
else
    PYTHON_CMD="python3"
    BLACK_CMD="black"
    ISORT_CMD="isort"
    FLAKE8_CMD="flake8"
    MYPY_CMD="mypy"
fi

echo "ğŸ” Running pre-commit checks on staged files..."
echo ""

ERRORS=0

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null || echo "")

if [ -z "$STAGED_FILES" ]; then
    echo -e "${YELLOW}âš ${NC} No staged files to check"
    exit 0
fi

# Filter staged files by type and check they exist
STAGED_PYTHON=""
STAGED_MARKDOWN=""
STAGED_JSON=""
STAGED_YAML=""

for file in $STAGED_FILES; do
    if file_exists "$file"; then
        case "$file" in
            *.py)
                STAGED_PYTHON="${STAGED_PYTHON}${STAGED_PYTHON:+$'\n'}$file"
                ;;
            *.md)
                STAGED_MARKDOWN="${STAGED_MARKDOWN}${STAGED_MARKDOWN:+$'\n'}$file"
                ;;
            *.json)
                STAGED_JSON="${STAGED_JSON}${STAGED_JSON:+$'\n'}$file"
                ;;
            *.yaml|*.yml)
                STAGED_YAML="${STAGED_YAML}${STAGED_YAML:+$'\n'}$file"
                ;;
        esac
    fi
done

# Function to run a check and track errors
run_check() {
    local name="$1"
    local command="$2"
    local log_file="${LOG_PREFIX}_${name// /_}.log"

    echo "â†’ Running $name..."
    if eval "$command" > "$log_file" 2>&1; then
        echo -e "${GREEN}âœ“${NC} $name passed"
        rm -f "$log_file"
        return 0
    else
        echo -e "${RED}âœ—${NC} $name failed"
        if [ -f "$log_file" ]; then
            cat "$log_file"
        fi
        rm -f "$log_file"
        ERRORS=$((ERRORS + 1))
        return 1
    fi
}

# Check if there are any Python files to check
if [ -n "$STAGED_PYTHON" ]; then
    # Convert newline-separated list to space-separated for commands, filtering existing files
    PYTHON_FILES=""
    for file in $STAGED_PYTHON; do
        if file_exists "$file"; then
            PYTHON_FILES="${PYTHON_FILES}${PYTHON_FILES:+ }$file"
        fi
    done

    if [ -n "$PYTHON_FILES" ]; then
        # Check if required tools are available (use venv tools if available)
        if ! command_exists "$PYTHON_CMD"; then
            echo -e "${RED}âœ—${NC} python3 not found (checked: $PYTHON_CMD)"
            ERRORS=$((ERRORS + 1))
        else
            # Check formatting on staged Python files
            if [ -f "$BLACK_CMD" ] || command_exists "$BLACK_CMD"; then
                run_check "Black formatting" "$BLACK_CMD --check $PYTHON_FILES"
            else
                echo -e "${YELLOW}âš ${NC} black not found (checked: $BLACK_CMD), skipping Black formatting check"
                echo ""
            fi

            if [ -f "$ISORT_CMD" ] || command_exists "$ISORT_CMD"; then
                run_check "isort import sorting" "$ISORT_CMD --check-only $PYTHON_FILES"
            else
                echo -e "${YELLOW}âš ${NC} isort not found (checked: $ISORT_CMD), skipping isort check"
                echo ""
            fi

            # Check linting on staged Python files
            if [ -f "$FLAKE8_CMD" ] || command_exists "$FLAKE8_CMD"; then
                if file_exists ".flake8"; then
                    run_check "flake8 linting" "$FLAKE8_CMD --config .flake8 $PYTHON_FILES --count --show-source --statistics"
                else
                    run_check "flake8 linting" "$FLAKE8_CMD $PYTHON_FILES --count --show-source --statistics"
                fi
            else
                echo -e "${YELLOW}âš ${NC} flake8 not found (checked: $FLAKE8_CMD), skipping flake8 check"
                echo ""
            fi

            # Check types on staged Python files
            if [ -f "$MYPY_CMD" ] || command_exists "$MYPY_CMD"; then
                echo "â†’ Running mypy type checking..."
                MYPY_LOG="${LOG_PREFIX}_mypy.log"
                if file_exists "pyproject.toml"; then
                    "$MYPY_CMD" --config-file pyproject.toml . > "$MYPY_LOG" 2>&1
                else
                    "$MYPY_CMD" . > "$MYPY_LOG" 2>&1
                fi
                MYPY_EXIT=$?

                if [ $MYPY_EXIT -eq 0 ]; then
                    echo -e "${GREEN}âœ“${NC} mypy type checking passed"
                else
                    # Filter mypy output to only show errors for staged files
                    FILTERED_ERRORS=$(grep -f <(echo "$STAGED_PYTHON" | sed 's|^|^|' | sed 's|$|:|') "$MYPY_LOG" 2>/dev/null || true)
                    if [ -n "$FILTERED_ERRORS" ]; then
                        echo -e "${RED}âœ—${NC} mypy type checking failed (errors in staged files)"
                        echo "$FILTERED_ERRORS"
                        ERRORS=$((ERRORS + 1))
                    else
                        echo -e "${GREEN}âœ“${NC} mypy type checking passed (no errors in staged files)"
                    fi
                fi
                rm -f "$MYPY_LOG"
                echo ""
            else
                echo -e "${YELLOW}âš ${NC} mypy not found, skipping mypy check"
                echo ""
            fi
        fi
    fi
else
    echo -e "${YELLOW}âš ${NC} No Python files staged, skipping Python checks"
    echo ""
fi

# Check markdown linting (required when markdown files are staged)
if [ -n "$STAGED_MARKDOWN" ]; then
    if command_exists markdownlint; then
        # Filter out wip and fixtures files (same as make lint-markdown)
        MARKDOWN_FILES=""
        for file in $STAGED_MARKDOWN; do
            if file_exists "$file"; then
                case "$file" in
                    docs/wip/*|tests/fixtures/*)
                        # Skip these files
                        ;;
                    *)
                        MARKDOWN_FILES="${MARKDOWN_FILES}${MARKDOWN_FILES:+ }$file"
                        ;;
                esac
            fi
        done

        if [ -n "$MARKDOWN_FILES" ]; then
            # Check if auto-fix is requested via environment variable
            if [ "$MARKDOWNLINT_FIX" = "1" ]; then
                echo "â†’ Auto-fixing markdown linting issues..."
                MD_FIX_LOG="${LOG_PREFIX}_md_fix.log"
                if file_exists ".markdownlint.json"; then
                    markdownlint --fix $MARKDOWN_FILES --ignore node_modules --ignore .venv --ignore .build/site --config .markdownlint.json > "$MD_FIX_LOG" 2>&1
                else
                    markdownlint --fix $MARKDOWN_FILES --ignore node_modules --ignore .venv --ignore .build/site > "$MD_FIX_LOG" 2>&1
                fi
                if [ $? -eq 0 ]; then
                    echo -e "${GREEN}âœ“${NC} Markdown auto-fix completed"
                    # Re-stage fixed files
                    echo "$MARKDOWN_FILES" | xargs git add 2>/dev/null || true
                else
                    echo -e "${YELLOW}âš ${NC} Some markdown issues could not be auto-fixed"
                    cat "$MD_FIX_LOG"
                fi
                rm -f "$MD_FIX_LOG"
                echo ""
            fi
            # Run linting check (after auto-fix if enabled)
            if file_exists ".markdownlint.json"; then
                run_check "Markdown linting" "markdownlint $MARKDOWN_FILES --ignore node_modules --ignore .venv --ignore .build/site --config .markdownlint.json"
            else
                run_check "Markdown linting" "markdownlint $MARKDOWN_FILES --ignore node_modules --ignore .venv --ignore .build/site"
            fi
        else
            echo -e "${YELLOW}âš ${NC} No markdown files to lint (all filtered out)"
            echo ""
        fi
    else
        echo -e "${RED}âœ—${NC} markdownlint not found but markdown files are staged"
        echo ""
        echo "Markdown linting is required when committing markdown files."
        echo "Install markdownlint with:"
        echo "  npm install -g markdownlint-cli"
        echo ""
        echo "Or skip this check with: git commit --no-verify"
        echo ""
        echo "Tip: Enable auto-fix by setting MARKDOWNLINT_FIX=1 before committing"
        echo ""
        ERRORS=$((ERRORS + 1))
    fi
else
    echo -e "${YELLOW}âš ${NC} No markdown files staged, skipping markdown checks"
    echo ""
fi

# Check JSON syntax validation (required when JSON files are staged)
if [ -n "$STAGED_JSON" ]; then
    if [ -f "$PYTHON_CMD" ] || command_exists "$PYTHON_CMD"; then
        echo "â†’ Running JSON syntax validation..."
        JSON_ERRORS=0
        for json_file in $STAGED_JSON; do
            if file_exists "$json_file"; then
                if "$PYTHON_CMD" -m json.tool "$json_file" > /dev/null 2>&1; then
                    echo -e "  ${GREEN}âœ“${NC} $json_file"
                else
                    echo -e "  ${RED}âœ—${NC} $json_file"
                    "$PYTHON_CMD" -m json.tool "$json_file" 2>&1 | head -5
                    JSON_ERRORS=$((JSON_ERRORS + 1))
                fi
            fi
        done
        if [ $JSON_ERRORS -eq 0 ]; then
            echo -e "${GREEN}âœ“${NC} JSON syntax validation passed"
        else
            echo -e "${RED}âœ—${NC} JSON syntax validation failed ($JSON_ERRORS file(s) with errors)"
            ERRORS=$((ERRORS + 1))
        fi
        echo ""
    else
        echo -e "${YELLOW}âš ${NC} python3 not found, skipping JSON validation"
        echo ""
    fi
else
    echo -e "${YELLOW}âš ${NC} No JSON files staged, skipping JSON checks"
    echo ""
fi

# Validate test infrastructure (when pytest config or test files change)
# Customize these patterns based on your project structure
STAGED_PYPROJECT=$(echo "$STAGED_FILES" | grep -E '(pyproject\.toml|Makefile|\.github/workflows/.*\.yml)$' || true)
STAGED_TEST_FILES=$(echo "$STAGED_FILES" | grep -E 'tests/.*\.py$' || true)

if [ -n "$STAGED_PYPROJECT" ] || [ -n "$STAGED_TEST_FILES" ]; then
    if ([ -f "$PYTHON_CMD" ] || command_exists "$PYTHON_CMD") && ([ -f ".venv/bin/pytest" ] || command_exists pytest); then
        echo "â†’ Validating test infrastructure..."
        # Check that integration marker works
        # Note: grep -c outputs "0" on no matches but returns exit code 1, so we use || true to suppress the exit code
        # Disable xdist and rerunfailures plugins during collection (they try to bind sockets which may fail in sandboxed environments)
        INTEGRATION_LOG="${LOG_PREFIX}_integration.log"
        PYTEST_CMD=""
        if [ -f ".venv/bin/pytest" ]; then
            PYTEST_CMD=".venv/bin/pytest"
        elif command_exists pytest; then
            PYTEST_CMD="pytest"
        else
            PYTEST_CMD="$PYTHON_CMD -m pytest"
        fi
        "$PYTHON_CMD" -m pytest tests/integration/ -m integration --collect-only -q -p no:rerunfailures -p no:xdist > "$INTEGRATION_LOG" 2>&1
        INTEGRATION_COUNT=$(grep -c "^tests/" "$INTEGRATION_LOG" 2>/dev/null || echo "0")
        # Strip any newlines and ensure we have a valid number (default to 0 if empty)
        INTEGRATION_COUNT=${INTEGRATION_COUNT//$'\n'/}
        INTEGRATION_COUNT=${INTEGRATION_COUNT:-0}

        # Only fail if we can't collect tests AND pytest didn't exit with a clear error
        if [ "$INTEGRATION_COUNT" -eq 0 ]; then
            # Check if pytest actually ran successfully (exit code 0 means it ran but found 0 tests)
            # If pytest failed with an error, that's a real problem
            if grep -q "ERROR\|FAILED\|ImportError\|ModuleNotFoundError" "$INTEGRATION_LOG" 2>/dev/null; then
                echo -e "${RED}âœ—${NC} Integration marker validation failed! pytest encountered errors:"
                grep -E "ERROR|FAILED|ImportError|ModuleNotFoundError" "$INTEGRATION_LOG" | head -5
                ERRORS=$((ERRORS + 1))
            else
                echo -e "${YELLOW}âš ${NC} Integration marker: No tests collected (this may be normal if no integration tests exist)"
            fi
        else
            echo -e "  ${GREEN}âœ“${NC} Integration marker: $INTEGRATION_COUNT tests"
        fi
        rm -f "$INTEGRATION_LOG"

        # Check that E2E marker works
        E2E_LOG="${LOG_PREFIX}_e2e.log"
        "$PYTHON_CMD" -m pytest tests/e2e/ -m e2e --collect-only -q -p no:rerunfailures -p no:xdist > "$E2E_LOG" 2>&1
        E2E_COUNT=$(grep -c "^tests/" "$E2E_LOG" 2>/dev/null || echo "0")
        # Strip any newlines and ensure we have a valid number (default to 0 if empty)
        E2E_COUNT=${E2E_COUNT//$'\n'/}
        E2E_COUNT=${E2E_COUNT:-0}

        if [ "$E2E_COUNT" -eq 0 ]; then
            # Check if pytest actually ran successfully
            if grep -q "ERROR\|FAILED\|ImportError\|ModuleNotFoundError" "$E2E_LOG" 2>/dev/null; then
                echo -e "${RED}âœ—${NC} E2E marker validation failed! pytest encountered errors:"
                grep -E "ERROR|FAILED|ImportError|ModuleNotFoundError" "$E2E_LOG" | head -5
                ERRORS=$((ERRORS + 1))
            else
                echo -e "${YELLOW}âš ${NC} E2E marker: No tests collected (this may be normal if no E2E tests exist)"
            fi
        else
            echo -e "  ${GREEN}âœ“${NC} E2E marker: $E2E_COUNT tests"
        fi
        rm -f "$E2E_LOG"

        if [ $ERRORS -eq 0 ]; then
            echo -e "${GREEN}âœ“${NC} Test infrastructure validation passed"
        fi
        echo ""
    else
        echo -e "${YELLOW}âš ${NC} python3 or pytest not found, skipping test infrastructure validation"
        echo ""
    fi
fi

# Check YAML syntax validation (required when YAML files are staged)
if [ -n "$STAGED_YAML" ]; then
    echo "â†’ Running YAML syntax validation..."
    YAML_ERRORS=0
    for yaml_file in $STAGED_YAML; do
        if file_exists "$yaml_file"; then
            # Try yamllint first if available (better error messages and handles custom tags)
            if command_exists yamllint; then
                YAML_LOG="${LOG_PREFIX}_yaml_${yaml_file//\//_}.log"
                yamllint "$yaml_file" > "$YAML_LOG" 2>&1
                if [ $? -eq 0 ]; then
                    echo -e "  ${GREEN}âœ“${NC} $yaml_file"
                else
                    echo -e "  ${RED}âœ—${NC} $yaml_file"
                    head -5 "$YAML_LOG"
                    YAML_ERRORS=$((YAML_ERRORS + 1))
                fi
                rm -f "$YAML_LOG"
            elif [ -f "$PYTHON_CMD" ] || command_exists "$PYTHON_CMD"; then
                # Fallback to Python yaml module - check basic syntax (ignore custom tags)
                YAML_LOG="${LOG_PREFIX}_yaml_${yaml_file//\//_}.log"
                "$PYTHON_CMD" -c "
import yaml
import sys
try:
    with open('$yaml_file', 'r') as f:
        # Try to parse YAML - if it fails, it's a syntax error
        list(yaml.safe_load_all(f))
    sys.exit(0)
except yaml.YAMLError as e:
    # Only fail on actual YAML syntax errors, not unknown tags
    if 'could not determine a constructor' in str(e) or 'tag:' in str(e):
        # Unknown tag - this is OK for syntax validation
        sys.exit(0)
    else:
        # Real syntax error
        print(e, file=sys.stderr)
        sys.exit(1)
except Exception as e:
    print(e, file=sys.stderr)
    sys.exit(1)
" > "$YAML_LOG" 2>&1
                if [ $? -eq 0 ]; then
                    echo -e "  ${GREEN}âœ“${NC} $yaml_file"
                else
                    echo -e "  ${RED}âœ—${NC} $yaml_file"
                    head -5 "$YAML_LOG"
                    YAML_ERRORS=$((YAML_ERRORS + 1))
                fi
                rm -f "$YAML_LOG"
            else
                echo -e "  ${YELLOW}âš ${NC} $yaml_file (no YAML validator available)"
            fi
        fi
    done
    if [ $YAML_ERRORS -eq 0 ]; then
        echo -e "${GREEN}âœ“${NC} YAML syntax validation passed"
    else
        echo -e "${RED}âœ—${NC} YAML syntax validation failed ($YAML_ERRORS file(s) with errors)"
        ERRORS=$((ERRORS + 1))
    fi
    echo ""
else
    echo -e "${YELLOW}âš ${NC} No YAML files staged, skipping YAML checks"
    echo ""
fi

# Summary
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
if [ $ERRORS -eq 0 ]; then
    echo -e "${GREEN}âœ“ All pre-commit checks passed!${NC}"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    exit 0
else
    echo -e "${RED}âœ— $ERRORS check(s) failed!${NC}"
    echo ""
    echo "Fix the issues above or use:"
    echo "  â€¢ make format       - Auto-fix formatting"
    echo "  â€¢ git commit --no-verify - Skip checks (not recommended)"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    exit 1
fi
